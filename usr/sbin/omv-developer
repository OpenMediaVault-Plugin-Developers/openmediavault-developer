#!/bin/bash
# shellcheck disable=SC1091,SC2010,SC2162,SC2086
#
# @author    Volker Theile <volker.theile@openmediavault.org>
# @author    OpenMediaVault Plugin Developers <plugins@omv-extras.org>
# @copyright Copyright (c) 2009-2013 Volker Theile
# @copyright Copyright (c) 2014-2025 OpenMediaVault Plugin Developers
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

set -e

. /etc/default/openmediavault
. /usr/share/openmediavault/scripts/helper-functions

export LC_ALL=C

command=$1
plugin=$2
location=$3
commit=$3
tag=${3//[[:space:]]/}
message=${4//[[:space:]]/}

xpath="//services/developer"
xpathlocation="${xpath}/locations/location[uuid='${location}']"

owner=$(omv_config_get "${xpath}/owner")
sfref=$(omv_config_get "${xpath}/sharedfolderref")
sfpath=$(omv_get_sharedfolder_path "${sfref}")
token=$(omv_config_get "${xpath}/txtoken")

txbin="/srv/plugins/tx/tx"

if [ -z "${sfpath}" ]; then
    echo "Error - shared folder not set."
    exit 1
fi

packagepath="${sfpath}/${plugin}"

initial()
{
    export LC_ALL=C
    if [ ! -d "${packagepath}" ]; then
        echo "Cloning ${plugin} from github to ${sfpath} ..."

        cd "${sfpath}"
        git clone https://github.com/OpenMediaVault-Plugin-Developers/${plugin}.git

        checkoutBranches
    fi
}

checkoutBranches() {
    [ -d "${packagepath}" ] || return 0

    local repo="${sfpath}/${plugin}"
    if [ ! -d "${repo}/.git" ]; then
        echo "Not a git repo: ${repo}" >&2
        return 1
    fi

    echo "Syncing branches for ${plugin} in ${repo} ..."
    pushd "${repo}" >/dev/null || return 1

    git fetch --prune --tags origin

    # Discover default branch via origin/HEAD (fallback to main/master)
    local default_branch
    default_branch="$(git symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null | cut -d/ -f2)"
    if [ -z "${default_branch}" ]; then
        if   git show-ref --verify --quiet refs/remotes/origin/main;   then default_branch="main"
        elif git show-ref --verify --quiet refs/remotes/origin/master; then default_branch="master"
        else
            default_branch="$(git for-each-ref --format='%(refname:short)' refs/remotes/origin \
                              | sed -E 's|^origin/||' | head -n1)"
        fi
    fi

    # Build a clean list of remote branch names (without the origin/ prefix)
    # and skip HEAD, default branch, and any weird/empty entries.
    local -a branches=()
    while IFS= read -r ref; do
        # ref like "origin/foo/bar"
        local name="${ref#origin/}"
        # Ensure it still exists exactly as a remote ref
        git show-ref --verify --quiet "refs/remotes/origin/${name}" || continue
        # Skip HEAD and default
        [ "${name}" = "HEAD" ] && continue
        [ "${name}" = "${default_branch}" ] && continue
        # Skip obviously bogus entry "origin" (would make origin/origin)
        [ "${name}" = "origin" ] && continue
        branches+=("${name}")
    done < <(git for-each-ref --format='%(refname:short)' refs/remotes/origin)

    # Create or fast-forward local tracking branches safely
    local b
    for b in "${branches[@]}"; do
        # Double-check the remote exists to avoid origin/origin issues.
        if ! git show-ref --verify --quiet "refs/remotes/origin/${b}"; then
            echo "Skipping missing remote ref: origin/${b}" >&2
            continue
        fi

        if git show-ref --verify --quiet "refs/heads/${b}"; then
            git branch --set-upstream-to="origin/${b}" "${b}" 2>/dev/null || true
            git switch -q "${b}" || continue
            git merge --ff-only "origin/${b}" >/dev/null 2>&1 || true
        else
            git switch -c "${b}" --track "origin/${b}" || {
                echo "Failed to create local branch for origin/${b}, skipping" >&2
                continue
            }
        fi
    done

    # Land on the default branch and fast-forward it
    if [ -n "${default_branch}" ]; then
        if git show-ref --verify --quiet "refs/heads/${default_branch}"; then
            git switch -q "${default_branch}"
        elif git show-ref --verify --quiet "refs/remotes/origin/${default_branch}"; then
            git switch -c "${default_branch}" --track "origin/${default_branch}"
        fi
        git merge --ff-only "origin/${default_branch}" >/dev/null 2>&1 || true
    fi

    popd >/dev/null
}

remove()
{
    if [ -d "${packagepath}" ]; then
        echo "Removing old files ..."
        rm -rfv ${packagepath}
    fi
}

build()
{
    export LC_ALL=C
    copylocation=$(omv_config_get "${xpath}/copylocation")
    echo "Building ${plugin}..."
    # Build directly in the package path
    cd "${packagepath}"
    rm -fv ../${plugin}*.deb
    if [ -f "${packagepath}/control" ]; then
        # Simple equivs package
        equivs-build control 2>&1
    else
        if grep -q "Architecture: any" debian/control; then
            for i in amd64 arm64; do
                echo $i
                dpkg-buildpackage -b -a $i
            done
        else
            fakeroot debian/rules clean binary 2>&1
        fi
    fi

    # Ensure ownership and optionally copy to another location
    chown ${owner}:users ${sfpath}/${plugin}*.deb 2>/dev/null || true
    copylocation=$(omv_config_get "${xpath}/copylocation")
    if [ -n "${copylocation}" ] && [ -d "${copylocation}" ]; then
        echo "Copying package to ${copylocation} ..."
        cp ${sfpath}/${plugin}*.deb "${copylocation}" 2>/dev/null || true
    fi
    fakeroot debian/rules clean
    if [ -n "${packagepath}" ] && [ ! "${packagepath}" = "/" ] && [ -n "${plugin}" ]; then
      echo "Cleaning up build files..."
      rm -rf "${packagepath}/debian/${plugin}"
    fi
}

update()
{
    export LC_ALL=C
    cd "${packagepath}"
    echo "Updating ${plugin} from github..."
    git pull
    git status
}

upload()
{
    remotehost=$(omv_config_get "${xpathlocation}/remotehost")
    remotepath=$(omv_config_get "${xpathlocation}/remotepath")
    port=$(omv_config_get "${xpathlocation}/port")
    username=$(omv_config_get "${xpathlocation}/username")
    password=$(omv_config_get "${xpathlocation}/password")

    search="${packagepath}_*"
    version=$(ls ${search})

    echo "Uploading ${version} to ${remotehost} ..."
    if [ -n "${password}" ]; then
        sshpass -p ${password} scp -P ${port} -o StrictHostKeyChecking=no "${version}" ${username}@${remotehost}:"${remotepath}"
    else
        su - ${owner} -c "scp -P ${port} -o StrictHostKeyChecking=no \"${version}\" ${username}@${remotehost}:\"${remotepath}\""
    fi
}

tx()
{
    repos="/root/.repos"
    tx_dir="${sfpath}/.tx"
    tx_file="${tx_dir}/config"

    jq .[].name /var/cache/openmediavault/dev_plugin_cache | sort | sed 's/"//g' | grep ^openmediavault | tee ${repos}

    mkdir -p "${tx_dir}"

    cat <<EOF > ${tx_file}
[main]
host = https://app.transifex.com
lang_map = de: de_DE, it: it_IT, ru: ru_RU, uk: uk_UK, da: da_DA, no: no_NO, sv: sv_SE, es: es_ES, fr: fr_FR, nl: nl_NL

EOF

    # repos
    while read repo; do
        cat <<EOF >> ${tx_file}
[o:openmediavault-plugin-developers:p:${repo}:r:${repo}pot]
file_filter            = ${repo}/usr/share/openmediavault/locale/<lang>/${repo}.po
source_file            = ${repo}/usr/share/openmediavault/locale/${repo}.pot
source_lang            = en
type                   = PO
minimum_perc           = 0
replace_edited_strings = false
keep_translations      = false

EOF
    done < ${repos}

    chown -R ${owner}:users ${tx_dir}
    rm -f ${repos}
}

buildpot()
{
    OMV_POT_DIR="${packagepath}/usr/share/openmediavault/locale"

    OMV_XGETTEXT_ARGS=" --keyword=_ --output-dir=${OMV_POT_DIR} \
      --output=${plugin}.pot --force-po --no-location --no-wrap \
      --sort-output --package-name=${plugin} --from-code=UTF-8 \
      --join-existing"

    mkdir -p "${OMV_POT_DIR}"
    rm -f "${OMV_POT_DIR}/${plugin}.pot"
    touch "${OMV_POT_DIR}/${plugin}.pot"
    cd "${packagepath}"
    echo "Building PO template file ..." >&2
    mkdir -p "${OMV_POT_DIR}"

    # Extract strings from YAML files.
    find ./usr/share/openmediavault/workbench/ \
      \( -iname "*.yaml" \) -type f -print0 | \
      xargs -0r xgettext ${OMV_XGETTEXT_ARGS} -

    # Extract strings from PHP files in usr/share/php if it exists
    if [ -d "./usr/share/php" ]; then
      find ./usr/share/php/ \
        \( -iname "*.php" -o -iname "*.inc" \) -type f -print0 | \
        xargs -0r xgettext ${OMV_XGETTEXT_ARGS} -
    fi

    # Extract strings from PHP files in usr/share/openmediavault
    find ./usr/share/openmediavault/ \
      \( -iname "*.php" -o -iname "*.inc" \) -type f -print0 | \
      xargs -0r xgettext ${OMV_XGETTEXT_ARGS} -

    # Remove '#, c-format' comments, otherwise manuall upload of translation
    # files confuses Transifex.
    sed --in-place '/^#, c-format/d' "${OMV_POT_DIR}/${plugin}.pot"
}

pushpot()
{
    cd "${sfpath}"
    TX_TOKEN=${token} ${txbin} push --source ${plugin}.${plugin}pot
}

pushpo()
{
    cd "${sfpath}"
    TX_TOKEN=${token} ${txbin} push -t ${plugin}.${plugin}pot
}

pullpo()
{
    cd "${sfpath}"
    TX_TOKEN=${token} ${txbin} pull --all --force ${plugin}.${plugin}pot
}

install()
{
    arch="$(dpkg --print-architecture)"
    search="${packagepath}_*"
    version=$(ls ${search} | grep -E "_all|_${arch}" | sort -h | tail -n1)

    echo "Installing ${plugin} ..."
    export LC_ALL=C
    export DEBIAN_FRONTEND=noninteractive
    cd "${packagepath}"
    if ! dpkg -i "${version}"; then
        echo "Resolving missing dependencies..."
        apt-get --fix-broken --no-install-recommends install -y
    fi
}

fixperms()
{
    local localbinpath="/usr/local/bin"
    local sbinpath="/usr/sbin"
    local etcsudoerspath="/etc/sudoers.d"
    local sysinfopath="/usr/share/openmediavault/sysinfo/modules.d"
    local varlibcronpath="/var/lib/openmediavault/cron.d"
    local prepath="/usr/share/openmediavault/release-upgrade/pre.d"
    local postpath="/usr/share/openmediavault/release-upgrade/post.d"
    local sleeppath="/etc/pm/sleep.d"
    local libsystemdsleep="/lib/systemd/system-sleep"

    echo "Fixing permissions in ${packagepath} ..."

    # Final ownership sweep (skip symlinks)
    chown -R -- "${owner}:users" "${packagepath}"

    # Default perms: files 0644, dirs 0755 (skip symlinks)
    find "${packagepath}" -type f -print0 | xargs -0 -r chmod 0644
    find "${packagepath}" -type d -print0 | xargs -0 -r chmod 0755

    # Make *.sh files executable
    find "${packagepath}" -type f -name '*.sh' -print0 | xargs -0 -r chmod 0755
    find "${packagepath}/debian/" -type f -name '*.service' -print0 | xargs -0 -r chmod 0755

    # Dirs whose *files* should be executable (if present)
    local exec_dirs=(
        "${localbinpath}" "${sbinpath}" "${sysinfopath}" "${varlibcronpath}"
        "${prepath}" "${postpath}" "${sleeppath}"
    )
    local d
    for d in "${exec_dirs[@]}"; do
        if [ -z "${d}" ]; then
            continue
        fi
        if [ -d "${packagepath}${d}" ]; then
            # Only regular files get +x; keeps subdir perms at 0755 from above
            echo "Fixing ${d} ..."
            find "${packagepath}${d}" -maxdepth 1 -type f -print0 | xargs -0 -r chmod 0755
        fi
    done

    if [ -d "${packagepath}${libsystemdsleep}" ]; then
        find "${packagepath}${libsystemdsleep}" -maxdepth 1 -type f -print0 | xargs -0 -r chmod +x
    fi

    if [ -d "${packagepath}${etcsudoerspath}" ]; then
        find "${packagepath}${etcsudoerspath}" -maxdepth 1 -type f -print0 | xargs -0 -r chmod 0440
        find "${packagepath}${etcsudoerspath}" -maxdepth 1 -type f -print0 | xargs -0 -r chown root:root
    fi

    # Debian build helpers (if present)
    if [ -f "${packagepath}/debian/rules" ]; then
        chmod 0755 "${packagepath}/debian/rules"
    fi

    chmod 0644 "${packagepath}/.gitattributes"
    chmod 0644 "${packagepath}/.gitignore"
    chmod 0644 "${packagepath}/README.md"
}

gitadd()
{
    cd "${packagepath}"
    echo "Adding all files ..."
    git add -A 2>&1
}

gitcommit()
{
    cd "${packagepath}"
    git commit -m "${commit}" 2>&1
}

gittag()
{
    if [ ! -f "/root/.netrc" ]; then
        echo ".netrc not found"
        exit 1
    fi

    cd "${packagepath}"
    git tag -a "${tag}" -m "${message}" 2>&1
    git push origin "${tag}" 2>&1
}

gitpush()
{
    if [ ! -f "/root/.netrc" ]; then
        echo ".netrc not found"
        exit 1
    fi

    cd "${packagepath}"
    git push 2>&1
}

gitstatus()
{
    cd "${packagepath}"
    git status 2>&1
}

gitdiff()
{
    cd "${packagepath}"
    git diff 2>&1
}

gitBranches()
{
    cd "${packagepath}"
    git branch
}

gitChangeBranch()
{
    cd "${packagepath}"
    git checkout "${location}" 2>&1
}

dchi()
{
    export DEBEMAIL="plugins@omv-extras.org"
    export DEBFULLNAME="OpenMediaVault Plugin Developers"
    cd "${packagepath}"
    if [ -f "debian/changelog" ]; then
        echo "Increment version ..."
        dch -U --no-auto-nmu "${commit}" 2>&1
        head -n 1 debian/changelog
    else
        echo "No changelog found."
    fi
}

dcha()
{
    export DEBEMAIL="plugins@omv-extras.org"
    export DEBFULLNAME="OpenMediaVault Plugin Developers"
    cd "${packagepath}"
    if [ -f "debian/changelog" ]; then
        echo "Add changelog line ..."
        dch -U --no-auto-nmu -a "${commit}" 2>&1
    else
        echo "No changelog found."
    fi
}

dchr()
{
    export DEBEMAIL="plugins@omv-extras.org"
    export DEBFULLNAME="OpenMediaVault Plugin Developers"
    cd "${packagepath}"
    if [ -f "debian/changelog" ]; then
        echo "Release version ..."
        dch -U --no-auto-nmu -r "release" -u "low" 2>&1
        head -n 1 debian/changelog
    else
        echo "No changelog found."
    fi

}

omvgit()
{
    echo "Installing OMV from github ..."
    export LC_ALL=C
    export DEBIAN_FRONTEND=noninteractive

    omvcode="openmediavault"
    omvcodepath="${sfpath}/${omvcode}"

    if [ ! -d "${omvcodepath}" ]; then
        cd "${sfpath}"
        git clone https://github.com/openmediavault/openmediavault.git
    else
        cd "${omvcodepath}"
        git pull
    fi

    # get revision
    cd "${omvcodepath}"
    revision=$(git rev-parse HEAD)
    echo "Revision ${revision}..."

    # get version
    cd "${omvcodepath}/deb/openmediavault"
    version=$(head -n 1 debian/changelog | cut -f2 -d"(" | cut -f1 -d")")
    echo "Version ${version}"

    # make git package
    cd "${omvcodepath}/deb/openmediavault"
    fakeroot debian/rules clean binary
    mv -v ../openmediavault_${version}_all.deb ${sfpath}/openmediavault_${version}-git${revision}_all.deb

    dpkg --force-confold -i "${sfpath}/openmediavault_${version}-git${revision}_all.deb"
    apt-get --yes --force-yes --fix-missing -f install

    echo "Purging internal cache ..."
    omv_purge_internal_cache
}

changelog()
{
    export LC_ALL=C
    cd "${packagepath}"
    head debian/changelog
}

echo "Command :: ${command}"
echo "Package path :: ${packagepath}"

case ${command} in
    update)
        initial
        update
        fixperms
    ;;

    reset)
        remove
        initial
        update
        fixperms
    ;;

    build)
        initial
        fixperms
        build
        fixperms
    ;;

    upload)
        initial
        fixperms
        build
        fixperms
        upload
    ;;

    tx)
        tx
    ;;

    buildpot)
        initial
        buildpot
        fixperms
    ;;

    pushpot)
        initial
        pushpot
        fixperms
    ;;

    pushpo)
        initial
        pushpo
        fixperms
    ;;

    pullpo)
        initial
        pullpo
        fixperms
    ;;

    install)
        initial
        fixperms
        build
        fixperms
        install
    ;;

    add)
        fixperms
        gitadd
    ;;

    commit)
        initial
        fixperms
        gitcommit
    ;;

    push)
        initial
        fixperms
        gitpush
    ;;

    tag)
        initial
        fixperms
        gittag
    ;;

    status)
        initial
        fixperms
        gitstatus
    ;;

    diff)
        initial
        fixperms
        gitdiff
    ;;

    branches)
        initial
        fixperms > /dev/null
        gitBranches
    ;;

    changebranch)
        initial
        fixperms
        gitChangeBranch
    ;;

    checkoutbranches)
        initial
        fixperms
        checkoutBranches
    ;;

    dchi)
        fixperms
        dchi
    ;;

    dcha)
        initial
        fixperms
        dcha
    ;;

    dchr)
        initial
        fixperms
        dchr
    ;;

    omvgit)
        omvgit
    ;;

    changelog)
        initial
        changelog
    ;;

    *)
    ;;
esac

exit 0
